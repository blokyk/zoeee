(warning: despite my definitive/confident tone, i don't know much about build systems "in the real world," since i almost always work on small personal projects, alone. take all this with a healthy dose of salt)

i always kind of disliked make and makefiles because they so often seem to sprawl out into a million unreadable lines. this is not helped by make's subjectively confusing syntax and million special identifiers. remembering what `$*`, `$^`, `$<`, `$@`, etc. all mean took a loooong time, and i still forget very often and have to test or look it up.

but if there's something nice about it, it's "pattern rules": specifying how whole classes of files should be built doesn't sound that impressive in 2025, but it is patently powerful (some make's approach to it can be limiting if one wishes *not* to curse their entire family line).

i've been trying to port a custom-made toolchain to nix recently (while still avoiding flakes), and while i now have most of the tools *technically* packaged, i just realised that the end destination isn't quite as pure as i'd like: to tie all those tools together, to make it accessible to the average person that doesn't want to write a dozen command to get their file from source to bitstream, i'm gonna have to... use make. i could technically write a bunch of `writeScriptApplication` or w/ever to wrap things up, but then the scripts' logic become basically just reimplementations of make, that need to handle being able to "build" files it doesn't know about in advance. there's no nice way to really do it, especially if you can't/don't want to use `nix run` and flakes.

what i'm realising, writing this out, is that, even though nix could be described as a build system, it is strictly oriented towards codebases that *already exist* and *already* have a functional build system. you could technically write derivations by hand for each files and every intermediary and everything -- but let's be honest, neither of us has time for that.

however, nix already has the making of a great *dev-time* build system, and my "thesis" is that pattern-rules-like ways to specify derivations would really help the ergonomics in that situation.